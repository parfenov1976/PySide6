"""
Пример использования библиотеки matplotlib для черчения графиков, диаграмм
и других способов визуализации данных.
В данном примере показано метод обновления рисунка при обновлении данных
путем перерисовки только линий графика по измененным данным.
"""
import sys
import random

from PySide6 import QtWidgets, QtCore  # PySide должен быть импортирован до matplotlib!!!

import matplotlib
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg
from matplotlib.figure import Figure

"""
Модуль random для работы со случайностями.
Модуль sys нужен для доступа к аргументам командной строки. Если использование аргументов
командной строки не предполагается, то импорт можно не выполнять. При этом, при создании
приложения в класс QtWidgets.QApplication([]) в качестве аргумента передается пустой список.
Импорт из библиотеки PySide6 модуля виджетов QtWidgets, модуля ядра библиотеки QtCore.
Импорт библиотеки matplotlib.
Импорт из модуля matplotlib.backends.backend_qtagg импорт класса холста для рисования FigureCanvasQTAgg
для библиотеки Qt.
Импорт из модуля matplotlib.figure класса контейнера верхнего уровня для всех элементов
визуализаций (чертежей) Figure.
Другие виджеты можно найти по ссылке https://doc.qt.io/qt-5/widget-classes.html#basic-widget-classes
"""

matplotlib.use('QtAgg')


# вызов метода для выбора бэкэнда библиотеки matplotlib для рисования и интеграции
# с библиотекой для создания графических интерфейсов


class MplCanvas(FigureCanvasQTAgg):
    """
    Подкласс холста для рисования от супер-класса холстов библиотеки matplotlib
    """

    def __init__(self, parent=None, width=5, height=4, dpi=100) -> None:
        """
        Конструктор хоста для рисования с указанием параметров по умолчанию
        :param parent: ссылка на родительский объект (из которого был создан экземпляр данного класса)
        :param width: ширина рисунка, количество значений dpi (n * dpi)
        :param height: высота рисунка, количество значений dpi (n * dpi)
        :param dpi: разрешение рисунка, точек на дюйм
        """
        fig = Figure(figsize=(width, height), dpi=dpi)  # создание контейнера с указанием размера и разрешения рисунка
        self.axes = fig.add_subplot(111)  # добавление осей к рисунку с указанием положения рисунка
        # в виде кода из трех цифр, первая - количество строк на сетке, вторая - количество столбцов на сетке,
        # третья - индекс последней ячейки, где будет размещен рисунок начиная с 1-ой (по умолчанию номер с 1-ой ячейки,
        # всегда 1 если опущен), индекс можно подать в виде кортежа (первая ячейка, последняя ячейка)
        # размер рисунка определяется его положением на сетке (сколько клеток он занимает)
        FigureCanvasQTAgg.__init__(self, fig)  # явный вызов конструктора родительского класса


class MainWindow(QtWidgets.QMainWindow):
    """
    Класс главного окна приложения от супер-класса главных окон
    """

    def __init__(self) -> None:
        """
        Конструктор главного окна приложения
        """
        QtWidgets.QMainWindow.__init__(self)  # явный вызов конструктора родительского класса
        self.canvas = MplCanvas(self, width=5, height=4, dpi=100)  # создание экземпляра класса холста для рисования
        # с указанием размеров рисунка из объекта matplotlib FigureCanvasQTAgg c одним набором осей (self.axes)
        self.setCentralWidget(self.canvas)  # размещение холста на главном окне приложения

        n_data = 50  # установка количества точек по оси x
        self.xdata = list(range(n_data))  # создание списка значений для оси х
        self.ydata = [random.randint(0, 10) for i in range(n_data)]  # создание списка значений по оси y
        self._plot_ref = None  # создание переменной для хранения ссылки на линию графика
        self.update_plot()  # вызов метода обновления рисунка

        self.timer = QtCore.QTimer()  # создание объекта таймера
        self.timer.setInterval(100)  # установка величины интервала таймера
        self.timer.timeout.connect(self.update_plot)  # создание сигнала на истечение таймера
        # с привязкой метода ресивера
        self.timer.start()  # запуск таймера

    def update_plot(self) -> None:
        """
        Метод обновления рисунка
        """
        self.ydata = self.ydata[1:] + [random.randint(0, 10)]  # удаление 1-го значения и добавление нового

        if self._plot_ref is None:  # проверяем наличие ссылки на линию графика
            # если ссылки нет, то рисуем график полностью
            plot_refs = self.canvas.axes.plot(self.xdata, self.ydata, 'r')  # создание рисунка графика по спискам данных
            # с указанием цвета линии и сохранение ссылки на него в переменную
            # метод .plot возвращает список ссылок на линии графика
            self._plot_ref = plot_refs[0]  # т.к. линия в данном примере одна, то обращаемся к первой по любому
        else:
            # если ссылка есть, то обновляем набор данных графика (список значений y)
            self._plot_ref.set_ydata(self.ydata)  # обновление данных

        self.canvas.draw()  # вызов метода для перерисовки холста


def main() -> None:
    """
    Функция запуска кода приложения верхнего уровня
    :return: None
    """
    app = QtWidgets.QApplication(sys.argv)  # создание основного цикла событий приложения
    window = MainWindow()  # создание экземпляра главного окна приложения
    app.setStyle('Fusion')  # более интересная глобальная кроссплатформенна тема Fusion
    window.show()  # установка видимости главного окна (по умолчанию окно спрятано)
    app.exec()  # запуск основного цикла событий приложения


if __name__ == '__main__':  # проверка имени запущенного модуля для предотвращения запуска
    # кода верхнего уровня данного модуля при его импортировании
    main()  # вызов функции запуска кода приложения верхнего уровня
