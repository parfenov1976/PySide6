"""
Пример использования модели таблиц и представления QTableView. В данном примере в качестве
структуры данных для таблицы будет файл базы данных sqlite.
Пример использования связанных таблиц для заполнения данных в представлении с использованием
модели связанных таблиц QSqlRelationalTableModel
"""

import sys
import re
from PySide6.QtCore import Qt, QSize
from PySide6.QtSql import QSqlDatabase, QSqlRelationalTableModel, QSqlRelation
from PySide6.QtWidgets import (
    QApplication,
    QMainWindow,
    QTableView,
    QLineEdit,
    QVBoxLayout,
    QWidget
)

"""
Модуль sys нужен для доступа к аргументам командной строки. Если использование аргументов
командной строки не предполагается, то импорт можно не выполнять. При этом, при создании
приложения в класс QApplication([]) в качестве аргумента передается пустой список.
Импорт из модуля PySide6.QtWidgets класса для управления приложением QApplication и
класса основного окна QMainWindow, класса ярлыка представления таблиц QTableView,
класс виджета однострочного текстового поля QLideEdit, класс слоя с вертикальной группировкой
виджетов QVBoxLayout и класс базового пустого виджета QWidget.
Импорт из модула PySide6.QtCore класса размеров двухмерных объектов QSize и класса Qt,
содержащего различные идентификаторы, используемые в библиотеке Qt.
Импорт из модуля PySide6.QtSql класса для установления связи с базой данных QSqlDatabase, 
класса модели связанных таблиц QSqlRelationalTableModel, класса для создания связи между
таблицами QSqlRelation.
"""

db = QSqlDatabase('QSQLITE')  # создание экземпляра объекта базы данных с присвоением имени
db.setDatabaseName('chinook.sqlite')  # указание имени файл базы данных
db.open()  # команда на открытие базы данных


class MainWindow(QMainWindow):
    """
    Подкласс главного окна приложения от супер класса главных окон
    """

    def __init__(self) -> None:
        """
        Конструктор главного окна приложения
        """
        QMainWindow.__init__(self)  # явный запуск конструктора родительского класса
        container = QWidget()  # создание контейнера для слоя с виджетами
        layout = QVBoxLayout()  # создание экземпляра класса слоя виджетов с вертикальной группировкой
        self.search = QLineEdit()  # создание текстового поля для ввода строки поиска
        self.search.textChanged.connect(self.update_filter)  # создание сигнала на изменение в строке поиска с
        # привязкой ресивера
        self.table = QTableView()  # создание экземпляра класса табличного представления
        layout.addWidget(self.search)  # размещение на слое строки поиска
        layout.addWidget(self.table)  # размещение на слое представления таблицы
        container.setLayout(layout)  # помещение в контейнер слоя с виджетами

        # tag:: relational model
        self.model = QSqlRelationalTableModel(db=db)  # создание модели связанной таблицы и привязка к ней базы данных
        self.table.setModel(self.model)  # подключение модели к представлению
        self.model.setTable('Track')  # выбор таблицы модели для передачи в представление
        relation = QSqlRelation('Album', 'AlbumId', 'Title')  # создание связи: Album - таблица с названиями альбомов,
        # AlbumId - ключевое поле с ИД альбомов в таблице Album, Title - колонка названий альбомов, которые будут
        # подставляться в представление вместо ИД.
        """
        ВАЖНОЕ ПРИМЕЧАНИЕ
        При установке связи в отображении название колонки в подключенной к представлению таблице изменится на название
        колонки из связанной таблицы. В данном примере вместо AlbumId будет отображаться Title. Однако, при замещении
        имени колонки методом .setHeaderData() обращаться нужно к исходному имени колонки подключенной к представлению
        таблицы. В данном примере к AlbumId (см. ниже)
        """
        self.model.setRelation(2, relation)  # установка связи с колонкой 2 подключенной к представлению таблицы
        self.model.setRelation(3, QSqlRelation('MediaType', 'MediaTypeId', 'Name'))  # установка связи с таблицей
        # типов медиа
        self.model.setRelation(4, QSqlRelation('Genre', 'GenreId', 'Name'))  # установка связи с таблицей названий
        # жанров музыки
        # end:: relational model

        column_titles = {
            'Name': 'Name',
            'AlbumId': 'Album Title',
            'MediaTypeId': 'Media Type',
            'GenreId': 'Genre',
            'Compose': 'Composer'
        }
        for n, t in column_titles.items():  # извлечение имени столбца в базе и имени для представления
            idx = self.model.fieldIndex(n)  # извлечение индекса столбца по его имени в базе
            self.model.setHeaderData(idx, Qt.Horizontal, t)  # присвоение имени столбцу по его индексу в базе
        # для отображения в представлении
        # Qt.Horizontal или Qt.Vertical задают или проверяют? ориентацию чего-то? Если задать Vertical,
        # то имя не присвоится
        self.model.select()  # выборка данных из подключенной таблицы базы данных

        self.setMinimumSize(QSize(1024, 600))  # установка минимального размера главного окна
        self.setCentralWidget(container)  # размещение представления таблицы в главном окне приложения

    def update_filter(self, s: str) -> None:
        """
        Метод ресивер (слот) сигнала на изменение содержимого строки поиска
        :param s: str - содержимое строки поиска
        :return: None

        ПРИМЕЧАНИЕ: в данном примере из-за установления связей с таблицами, из которых мы берем содержимое колонки Name
        в таблице появилось несколько колонок с данным наименованием, оно стало не уникальным и фильтрация по данной
        колонке перестала работать. Поскольку, фильтр работает с наименованиями колонок из базы данных замещение
        названий не меняет ситуацию. Фильтрация по другим колонкам (с уникальными названиями) работает.
        """
        s = re.sub(r'[\W_]+', '', s)  # очистка строки содержимого строки поиска от небуквенных включений
        # Если в строке поиска попадется двойная кавычка, то метод фильтрации зависнет, т.к. будет сформирована
        # некорректная строка поиска
        filer_str = f'Name LIKE "{s}%"'  # формирование строки поиска для передачи в метод фильтрации
        # фильтрация по столбцу Name (по исходному имени столбца из подключенной к представлению таблицы,
        # не по замещенному имени), выбирается все, что начинается с s
        self.model.setFilter(filer_str)  # фильтрация данных из таблицы


def main() -> None:
    """
    Функция запуска кода верхнего уроня приложения
    """
    app = QApplication(sys.argv)  # создание экземпляра основного цикла событий главного окна приложения
    window = MainWindow()  # создание экземпляра главного окна приложения
    window.show()  # установка видимости окна, по умолчанию окно скрыто
    app.exec()  # запуск основного цикла событий главного окна приложения


if __name__ == '__main__':  # конструкция для предотвращения запуска кода верхнего уровня при импортировании
    # данного файла как модуля
    main()  # вызов функции запуска кода верхнего уровня приложения
