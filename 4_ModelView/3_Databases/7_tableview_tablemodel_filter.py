"""
Пример использования модели таблиц и представления QTableView. В данном примере в качестве
структуры данных для таблицы будет файл базы данных sqlite.
Пример фильтрации данных с использованием метода .setFilter(). Фильтры задаются как в SQL
после ключевого слова WHERE, но без него, т.е. например name="Martin", name LIKE "Ma%" и т.д.
"""

import sys
import re
from PySide6.QtCore import Qt, QSize
from PySide6.QtSql import QSqlDatabase, QSqlTableModel
from PySide6.QtWidgets import (
    QApplication,
    QMainWindow,
    QTableView,
    QLineEdit,
    QVBoxLayout,
    QWidget
)

"""
Модуль sys нужен для доступа к аргументам командной строки. Если использование аргументов
командной строки не предполагается, то импорт можно не выполнять. При этом, при создании
приложения в класс QApplication([]) в качестве аргумента передается пустой список.
Импорт из модуля PySide6.QtWidgets класса для управления приложением QApplication и
класса основного окна QMainWindow, класса ярлыка представления таблиц QTableView,
класс виджета однострочного текстового поля QLideEdit, класс слоя с вертикальной группировкой
виджетов QVBoxLayout и класс базового пустого виджета QWidget.
Импорт из модула PySide6.QtCore класса размеров двухмерных объектов QSize и класса Qt,
содержащего различные идентификаторы, используемые в библиотеке Qt.
Импорт из модуля PySide6.QtSql класса для установления связи с базой данных QSqlDatabase, 
класса модели таблиц, не имеющих связей с другими таблица базы данных, QSqlTableModel.
"""

db = QSqlDatabase('QSQLITE')  # создание экземпляра объекта базы данных с присвоением имени
db.setDatabaseName('chinook.sqlite')  # указание имени файл базы данных
db.open()  # команда на открытие базы данных


class MainWindow(QMainWindow):
    """
    Подкласс главного окна приложения от супер класса главных окон
    """

    def __init__(self) -> None:
        """
        Конструктор главного окна приложения
        """
        QMainWindow.__init__(self)  # явный запуск конструктора родительского класса
        container = QWidget()  # создание контейнера для слоя с виджетами
        layout = QVBoxLayout()  # создание экземпляра класса слоя виджетов с вертикальной группировкой
        self.search = QLineEdit()  # создание текстового поля для ввода строки поиска
        self.search.textChanged.connect(self.update_filter)  # создание сигнала на изменение в строке поиска с
        # привязкой ресивера
        self.table = QTableView()  # создание экземпляра класса табличного представления
        layout.addWidget(self.search)  # размещение на слое строки поиска
        layout.addWidget(self.table)  # размещение на слое представления таблицы
        container.setLayout(layout)  # помещение в контейнер слоя с виджетами
        self.model = QSqlTableModel(db=db)  # создание модели таблицы и привязка к ней базы данных
        self.table.setModel(self.model)  # подключение модели к представлению
        self.model.setTable('Track')  # выбор таблицы модели для передачи в представление
        column_titles = {
            'Name': 'Name',
            'AlbumId': 'Album (ID)',
            'MediaTypeId': 'Media Type (ID)',
            'GenreId': 'Genre (ID)',
            'Compose': 'Composer'
        }
        for n, t in column_titles.items():  # извлечение имени столбца в базе и имени для представления
            idx = self.model.fieldIndex(n)  # извлечение индекса столбца по его имени в базе
            self.model.setHeaderData(idx, Qt.Horizontal, t)  # присвоение имени столбцу по его индексу в базе
        # для отображения в представлении
        # Qt.Horizontal или Qt.Vertical задают или проверяют? ориентацию чего-то? Если задать Vertical,
        # то имя не присвоится
        self.model.select()  # выборка данных из подключенной таблицы базы данных

        self.setMinimumSize(QSize(1024, 600))  # установка минимального размера главного окна
        self.setCentralWidget(container)  # размещение представления таблицы в главном окне приложения

    def update_filter(self, s: str) -> None:
        """
        Метод ресивер (слот) сигнала на изменение содержимого строки поиска
        :param s: str - содержимое строки поиска
        :return: None
        """
        s = re.sub(r'[\W_]+', '', s)  # очистка строки содержимого строки поиска от небуквенных включений
        # Если в строке поиска попадется двойная кавычка, то метод фильтрации зависнет, т.к. будет сформирована
        # некорректная строка поиска
        filer_str = f'Name LIKE "{s}%"'  # формирование строки поиска для передачи в метод фильтрации
        # фильтрация по столбцу Name, выбирается все, что начинается с s
        self.model.setFilter(filer_str)  # фильтрация данных из таблицы


def main() -> None:
    """
    Функция запуска кода верхнего уроня приложения
    """
    app = QApplication(sys.argv)  # создание экземпляра основного цикла событий главного окна приложения
    window = MainWindow()  # создание экземпляра главного окна приложения
    window.show()  # установка видимости окна, по умолчанию окно скрыто
    app.exec()  # запуск основного цикла событий главного окна приложения


if __name__ == '__main__':  # конструкция для предотвращения запуска кода верхнего уровня при импортировании
    # данного файла как модуля
    main()  # вызов функции запуска кода верхнего уровня приложения
