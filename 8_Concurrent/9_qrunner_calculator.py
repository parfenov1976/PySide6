"""
Пример использования много поточности для обеспечения работы полосы индикатора прогресса
Для этого используем два класса из модуля PySide6.QtCore:
QRunnable - контейнер для кода, который необходимо выполнить
QThreadPool - менеджер рабочих потоков
Также понадобиться класс декоратора Slot и класс сигнала Signal
В данном примере рассмотрено отслеживание прогресса нескольких рабочих потоков
и отображение его на одном индикаторе прогресса. Устранено проблема рывков
индикатора по мере завершения отдельных рабочих потоков.
"""
import sys
import time
import random
import uuid
import pyqtgraph as pg

from PySide6.QtWidgets import (QApplication,
                               QVBoxLayout,
                               QMainWindow,
                               QPushButton,
                               QWidget,
                               )
from PySide6.QtCore import QTimer, QRunnable, Slot, QThreadPool, Signal, QObject

"""
Модуль uuid библиотека для создания уникальных идентификаторов.
Модуль random библиотек для генерации случайностей.
Модуль time с библиотеками для работы со временем.
Библиотека для черчения графиков pyqtgraph.
Модуль sys нужен для доступа к аргументам командной строки. Если использование аргументов
командной строки не предполагается, то импорт можно не выполнять. При этом, при создании
приложения в класс QApplication([]) в качестве аргумента передается пустой список.
Импорт из модуля PySide6.QtWidgets класса для управления приложением QApplication и класса слоев
для виджетов с вертикальной организацией QVBoxLayout, класса виджета кнопки QPushButton,
класса базового виджета QWidget.
Импорт из модуля PySide6.QtCore класса таймера для измерения времени QTimer, класс контейнера для
исполняемого кода QRunnable, класс менеджера потоков QThreadPool, класс декоратора Slot,
класс сигнала Signal, класс базового объекта QObject.
Другие виджеты можно найти по ссылке https://doc.qt.io/qt-5/widget-classes.html#basic-widget-classes
"""


class WorkerSignals(QObject):
    """
    Класс сигналов рабочего потока, определяющий набор сигналов
    data кортеж параметров точки в виде (worker_id, x, y)
    """
    data = Signal(tuple)  # создание сигнала для передачи данных c параметрами точки


class Worker(QRunnable):
    """
    Рабочий поток - подкласс контейнера для исполняемого кода.
    Наследуется от супер класса QRannable для управления рабочими потоками, сигналами
    и результатов работы.
    """

    def __init__(self, iterations: int = 5) -> None:
        """
        Конструктор рабочего потока
        """
        QRunnable.__init__(self)  # явный вызов конструктора родительского класса
        self.worker_id = uuid.uuid4().hex  # генерация случайного уникального идентификатора
        self.signals = WorkerSignals()  # создаем экземпляр класса сигналов

    @Slot()  # данный декоратор помечает метод как слот
    def run(self) -> None:
        """
        Код, который необходимо выполнить помещаем в метод с именем run()
        """
        total_n = 1000  # установка количества интервалов для эмуляции какого либо процесса
        y2 = random.randint(0, 10)  # генерация случайного значения для величины y2
        delay = random.random() / 100  # генерация случайной величины задержки
        value = 0  # создание переменной для хранения вычисленной величины
        for n in range(total_n):  # запуск цикла определения степени выполнения
            # симулятор вычислений, каждый рабочий поток производит случайные значения
            # величин y и y2
            y = random.randint(0, 10)  # генерация случайного значения для величины y
            value += n * y2 - n * y  # вычисление значения величины value
            self.signals.data.emit((self.worker_id, n, value))  # передача параметров точки сигналу на отрисовку
            time.sleep(delay)  # выполнение задержки


class MainWindow(QMainWindow):
    """
    Подкласс главного окна приложения от супер класса главных окон
    """

    def __init__(self) -> None:
        """
        Конструктор главного окна приложения
        """
        QMainWindow.__init__(self)  # явный вызов конструктора родительского класса

        self.threadpool = QThreadPool()  # создание экземпляра класса менеджера потоков
        self.x = {}  # создание аттрибута для хранения точек отсчетов по времени
        self.y = {}  # создание аттрибута для хранения параметров точек
        self.lines = {}  # создание аттрибута для хранения ссылок на вычерченые линии для обновления
        layout = QVBoxLayout()  # создание экземпляра слоев для размещения виджетов
        self.graphWidget = pg.PlotWidget()  # создание экземпляра пространства чертежа
        self.graphWidget.setBackground('w')  # установка цвета заднего фона чертежа
        layout.addWidget(self.graphWidget)  # размещение пространства чертежа в слое для виджетов
        button = QPushButton('Create New Worker')  # создание экземпляра кнопки с надписью
        button.pressed.connect(self.execute)  # создание сигнала на нажатие кнопки с привязкой метода
        layout.addWidget(button)  # размещение на слое кнопки
        container = QWidget()  # создание контейнера для слоев с виджетами
        container.setLayout(layout)  # размещение в контейнере слоя для виджетов
        self.setCentralWidget(container)  # размещение контейнера со слоями для виджетов в главном окне приложения

    def execute(self) -> None:
        """
        Метод ресивер (слот), запускающий эмуляцию выполнения кода по нажатию кнопки
        :return: None
        """
        worker = Worker()  # создаем экземпляр рабочего потока
        worker.signals.data.connect(self.receive_data)  # создание сигнала на завершение
        # вычисления с привязкой ресивера
        self.threadpool.start(worker)  # запуск рабочего потока на исполнение

    def receive_data(self, data: tuple) -> None:
        """
        Метод ресивер (слот) для получения данных и отрисовка графика на их основе
        :param data: tuple - данные с параметрами точки
        :return: None
        """
        worker_id, x, y = data  # распаковка значение параметров точки
        if worker_id not in self.lines:  # Проверка на наличие идентификатора рабочего потока
            # в сохраненных ссылках на отрисованные линии. Если идентификатор рабочего потока
            # не найден в словаре, то производится отрисовка линии и сохранение ссылки на нее
            self.x[worker_id] = [x]  # сохранение координаты x
            self.y[worker_id] = [y]  # сохранение координаты y
            pen = pg.mkPen(width=2,  # создание пера со случайным цветом
                           color=(
                               random.randint(100, 255),
                               random.randint(100, 255),
                               random.randint(100, 255),
                           ),
            )
            self.lines[worker_id] = self.graphWidget.plot(self.x[worker_id], self.y[worker_id], pen=pen)
            # рисование линии и сохранение ссылки на нее
            return  # возврат из метода
        self.x[worker_id].append(x)  # обновление величины координаты x
        self.y[worker_id].append(y)  # обновление величины координаты y
        self.lines[worker_id].setData(self.x[worker_id], self.y[worker_id])


def main() -> None:
    """
    Функция запуска кода приложения верхнего уровня
    :return: None
    """
    app = QApplication(sys.argv)  # создание экземпляра класса основного цикла событий приложения
    window = MainWindow()  # создание экземпляра класса главного окна приложения
    app.setStyle('Fusion')  # более интересная глобальная кроссплатформенна тема Fusion
    window.show()  # установка видимости главного окна (по умолчанию окно спрятано)
    app.exec()  # запуск основного цикла событий приложения


if __name__ == '__main__':  # данная конструкция предотвращает запуск кода верхнего уровня
    # при импортировании данного файла как модуля
    main()  # вызов функции запуска кода верхнего уровня приложения
