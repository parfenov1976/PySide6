"""
Пример использования много поточности при запуске внешнего процесса.
Для этого используем два класса из модуля PySide6.QtCore:
QRunnable - контейнер для кода, который необходимо выполнить
QThreadPool - менеджер рабочих потоков.
Также понадобиться класс декоратора Slot и класс сигнала Signal
В данном примере внешний процесс запускается с помощью встроенной библиотеки python subprocess
и добавлен метод вывода результата работы внешнего процесса.
"""
import subprocess
import sys
import time
import traceback
import uuid
from collections import namedtuple

from PySide6.QtWidgets import (QApplication,
                               QLineEdit,
                               QVBoxLayout,
                               QMainWindow,
                               QPushButton,
                               QSpinBox,
                               QWidget,
                               )
from PySide6.QtCore import QRunnable, Slot, QThreadPool, Signal, QObject, QTimer, Qt

"""
Модуль subprocess для работы с внешними процессами
Модуль uuid библиотека для создания уникальных идентификаторов
Библиотека namedtuple из модуля collections для создания подкласса кортежа с именами (по аналогии со словарями)
Модуль time для работы со временем.
Модуль traceback для работы с трассировками стека программы.
Модуль sys нужен для доступа к аргументам командной строки. Если использование аргументов
командной строки не предполагается, то импорт можно не выполнять. При этом, при создании
приложения в класс QApplication([]) в качестве аргумента передается пустой список.
Импорт из модуля PySide6.QtWidgets класса для управления приложением QApplication и класса слоев
для виджетов с вертикальной организацией QVBoxLayout, класса виджета кнопки QPushButton,
класс виджета однострочного редактируемого текстового поля QLineEdit, класс виджета спин бокса QSpinBox,
класс базового виджета QWidget.
Импорт из модуля PySide6.QtCore класса таймера для измерения времени QTimer, класс контейнера для
исполняемого кода QRunnable, класс менеджера потоков QThreadPool, класс декоратора Slot,
класс сигнала Signal, класс базового объекта QObject, класс таймера для измерения времени QTimer.
Qt - содержит различные идентификаторы, используемые в библиотеке Qt
Другие виджеты можно найти по ссылке https://doc.qt.io/qt-5/widget-classes.html#basic-widget-classes
"""


def extract_vars(line: str) -> dict:
    """
    Функция обработки результата работы внешнего процесса -
    преобразование текста из внешнего процесса со строками типа "name=value" в словарь.
    :param line: str - строка с переменными и значениями вида name=value
    :return: dict - словарь с результатами разбора строки с переменными и значениями
    """
    data = {}  # создание словаря для хранения результатов
    for s in line.splitlines():  # цикл по списку строк, полученному из файла разбиением на строки
        if '=' in s:  # проверка строки на соответствие шаблону key=value
            name, value = s.split('=')  # разбиение строки по знаку = и присвоение результата переменным
            data[name] = value  # создание в словаре для результатов пары ключ-значение
    data['number_of_lines'] = len(line)  # добавление в словарь результатов информации по длине исходной строки
    return data


class WorkerSignals(QObject):
    """
    Класс сигналов рабочего потока, определяющий набор сигналов
    Перечень поддерживаемых сигналов:
    finished - без данных, сигнал о завершении исполнения кода функции
    result - словарь с результатом работы кода
    """
    finished = Signal()
    result = Signal(dict)


class SubProcessWorker(QRunnable):
    """
    Рабочий поток - подкласс контейнера для исполняемого кода внешнего процесса.
    Наследуется от супер класса QRannable для управления рабочими потоками, сигналами c
    результатами работы.
    """

    def __init__(self, command, process_result=None) -> None:
        """
        Конструктор рабочего потока.
        :param command: команда для запуска во внешнем процессе
        """
        QRunnable.__init__(self)  # явный вызов конструктора родительского класса
        self.signals = WorkerSignals()  # создание экземпляра класса сигналов рабочего потока
        self.command = command  # сохранение команд для исполнения в аттрибуте рабочего потока
        self.process_result = process_result  # сохранение ссылки на функцию обработчик
        # результатов работы внешнего процесса

    @Slot()  # данный декоратор помечает метод как слот
    def run(self) -> None:
        """
        Код рабочего потока для запуска функции с передачей ей аргументов
        """
        output = subprocess.getoutput(self.command)  # запуск команд внешнего процесса и сохранение
        # результатов в переменной
        if self.process_result:  # проверка наличия обработчика для результатов
            output = self.process_result(output)  # передача обработчику результатов работы внешнего процесса
        self.signals.result.emit(output)  # передача результатов работы внешнего процесса
        # объекту сигналов рабочего потока
        self.signals.finished.emit()  # сообщение о завершении работы внешнего процесса
        # объекту сигналов рабочего потока


class MainWindow(QMainWindow):
    """
    Подкласс главного окна приложения от супер класса главных окон
    """

    def __init__(self) -> None:
        """
        Конструктор главного окна приложения
        """
        QMainWindow.__init__(self)  # явный вызов конструктора родительского класса
        layout = QVBoxLayout()  # создание экземпляра слоев для размещения виджетов
        self.name = QLineEdit()  # создание экземпляра редактируемого однострочного текстового
        # поля для имени
        self.country = QLineEdit()  # создание экземпляра редактируемого однострочного текстового
        # поля для наименования страны
        self.website = QLineEdit()  # создание экземпляра редактируемого однострочного текстового
        # поля для наименования странички в интернете
        self.number_of_lines = QSpinBox()  # создание экземпляра спин бокса для указания количества строк
        btn_run = QPushButton('Execute!')  # создание кнопки с надписью
        btn_run.clicked.connect(self.start)  # создание сигнала на нажатие кнопки с привязкой метода ресивера
        layout.addWidget(self.name)  # размещение текстового поля в слое для виджетов
        layout.addWidget(self.country)  # размещение текстового поля в слое для виджетов
        layout.addWidget(self.website)  # размещение текстового поля в слое для виджетов
        layout.addWidget(btn_run)  # размещение кнопки в слое для виджетов
        container = QWidget()  # создание контейнера для слоев с виджетами
        container.setLayout(layout)  # размещение в контейнере слоя для виджетов
        self.setCentralWidget(container)  # размещение контейнера в главном окне приложения
        self.threadpool = QThreadPool()  # создание экземпляра класса менеджера потоков
        print(f'Multithreading with maximum {self.threadpool.maxThreadCount()}')
        # вывод максимального количества доступных потоков

    def start(self) -> None:
        """
        Метод ресивер (слот) на нажатие кнопки запуска выполнения внешнего процесса
        :return: None
        """
        self.runner = SubProcessWorker('python dummy_script.py', process_result=extract_vars)
        # создание экземпляра рабочего потока для запуска кода внешнего процесса dummy_script.py с передачей ссылки
        # на функцию обработчик результатов работы внешнего процесса extract_vars
        self.runner.signals.result.connect(self.result)  # создание сигнала на передачу результата с привязкой ресивера
        self.threadpool.start(self.runner)  # запуск рабочего потока

    def result(self, data: dict) -> None:
        """
        Метод ресивер (слот) на завершение выполнения кода внешнего процесса
        :return: None
        """
        print(data)  # вывод словаря с обработанными результатами работы внешнего процесса
        self.name.setText(data['name'])
        self.country.setText(data['country'])
        self.website.setText(data['website'])
        self.number_of_lines.setValue(data['number_of_lines'])


def main() -> None:
    """
    Функция запуска кода приложения верхнего уровня
    :return: None
    """
    app = QApplication(sys.argv)  # создание экземпляра класса основного цикла событий приложения
    window = MainWindow()  # создание экземпляра класса главного окна приложения
    window.show()  # установка видимости главного окна (по умолчанию окно спрятано)
    app.exec()  # запуск основного цикла событий приложения


if __name__ == '__main__':  # данная конструкция предотвращает запуск кода верхнего уровня
    # при импортировании данного файла как модуля
    main()  # вызов функции запуска кода верхнего уровня приложения
