"""
Списки и таблицы. Управление выделением элементов

Класс QItemSelectionModel, определенный в модуле QtCore, реализует модель, позволяющую
централизованно управлять выделением сразу в нескольких представлениях. Установить
модель выделения позволяет метод setSelectionModel() класса QAbstractItemView, а
получить ссылку на модель можно с помощью метода selectionModel(). Если одна модель
выделения установлена сразу в нескольких представлениях, то выделение элемента в одном
представлении приведет к выделению соответствующего элемента в другом представлении.
Иерархия наследования выглядит так:
QObject - QItemSelectionModel
Форматы конструктора класса QItemSelectionModel:
QItemSelectionModel([<Модель>])
QItemSelectionModel(<Модель>, <Родитель>)
Класс QItemSelectionModel поддерживает следующие полезные методы (полный их список
можно найти на странице https://doc.qt.io/qt-6/qitemselectionmodel.html):
♦ hasSelection() - возвращает значение True, если существует выделенный элемент,
  и False - в противном случае;
♦ isSelected(<Индекс QModelIndex>) - возвращает значение True, если элемент с указанным
  индексом выделен, и False - в противном случае;
♦ isRowSelected(<Индекс> [, <Индекс родителя QModelIndex>]) - возвращает значение
  True, если строка с указанными индексом и индексом родителя выделена, и False - в противном
  случае. Если индекс родителя не указан, проверяется строка верхнего уровня иерархии;
♦ isColumnSelected(<Индекс> [, <Индекс родителя QModelindex>]) - возвращает значение
  True, если столбец с указанными индексом и индексом родителя выделен, и False -
  в противном случае. Если индекс родителя не указан, проверяется столбец верхнего уровня
  иерархии;
♦ rowIntersectsSelection(<Индекс>[, <Индекс родителя QModelIndex>]) - возвращает
  значение True, если строка с указанными индексом и индексом родителя содержит выделенный
  элемент, и False - в противном случае. Если индекс родителя не указан, проверяется
  строка верхнего уровня иерархии;
♦ columnIntersectsSelection(<Индекс>[, <Индекс родителя QModelIndex>]) - возвращает
  значение True, если столбец с указанными индексом и индексом родителя содержит
  выделенный элемент, и False - в противном случае. Если индекс родителя не указан,
  проверяется столбец верхнего уровня иерархии;
♦ selectedIndexes() - возвращает список индексов (объектов класса QModelIndex) выделенных
элементов или пустой список, если выделенных элементов нет;
♦ selectedRows([<Индекс столбца>=0]) - возвращает СПИСОК индексов(объектов класса
  QModelIndex) выделенных элементов из указанного столбца. Элемент попадет в список
  только в том случае, если строка выделена полностью;
♦ selectedColumns([<Индекс 􀂶троки>=0]) - возвращает список индексов (объектов класса
  QModelIndex) выделенных элементов из указанной строки. Элемент попадет в список
  только в том случае, если столбец выделен полностью;
♦ selection() - возвращает ссылку на объект класса QItemSelection;
♦ select (<Индекс QModelIndex>, <Режим>) -изменяет выделение элемента с указанным
индексом. Во втором параметре указываются следующие элементы (или их комбинация
через оператор |) перечисления SelectionFlag из класса QItemSelectionModel:
  • NoUpdate - без изменений;
  • Clear - снимает выделение всех элементов;
  • Select - выделяет элемент;
  • Deselect - снимает выделение с элемента;
  • Toggle - выделяет элемент, если он не выделен, или снимает выделение, если элемент
    был выделен;
  • Current - обновляет выделение текущего элемента;
  • Rows - индекс будет расширен так, чтобы охватить всю строку;
  • Columns - индекс будет расширен так, чтобы охватить весь столбец;
  • SelectCurrent - комбинация Select | Current;
  • ToggleCurrent - комбинация Toggle | Current;
  • ClearAndSelect - комбинация Clear | Select.
  Метод является слотом;
♦ select (<Выделение QItemSelection>, <Режим>) - задает новое выделение элементов.
  Метод является слотом;
♦ setCurrentIndex(<Индекс QModelindex>, <Режим>) - делает элемент с заданным индексом
  текущим и изменяет режим выделения. Метод является слотом;
♦ currentIndex() -возвращает индекс (объект класса QModelindex) текущего элемента;
♦ clearSelection() -снимает все выделения. Метод является слотом.
Класс QItemSelectionModel поддерживает следующие сигналы:
♦ currentChanged(<Предыдущий индекс>, <Новый индекс>) - генерируется при выделении
  другого элемента. Внутри обработчика через первый параметр доступен индекс ранее
  выделенного элемента, а через второй - индекс вновь выделенного элемента(объекты
  класса QModelIndex);
♦ currentRowChanged(<Предыдущий индекс>, <Новый индекс>) - генерируется при выделении
  элемента из другой строки. Внутри обработчика через первый параметр доступен
  индекс предыдущего элемента, а через второй - индекс нового элемента (объекты класса
  QModelIndex);
♦ currentColumnChanged(<Предыдущий индекс>, <Новый индекс>) - генерируется при выделении
  элемента из другого столбца. Внутри обработчика через первый параметр доступен
  индекс предыдущего элемента, а через второй индекс нового элемента (объекты
  класса QModelIndex);
♦ selectionChanged(<Предыдущее выделение>, <Новое выделение>) - генерируется при
  изменении выделения. Внутри обработчика через первый параметр доступно предыдущее
  выделение, а через второй - новое выделение (объекты класса QItemSelection).
"""

from PySide6.QtWidgets import (QMainWindow,
                               QTableView,
                               QVBoxLayout,
                               QWidget,
                               QLabel,
                               )
from PySide6.QtGui import (QStandardItemModel,
                           QIcon,
                           QStandardItem,
                           )
from PySide6.QtCore import QItemSelectionModel
import os

"""
Импорт из модуля PySide6.QtWidgets класса главных окон QMainWindow,
класса представления таблицы QTableView, класс вертикальной стопки для виджетов QVBoxLayout,
класса базового пустого виджета QWidget, класса ярлыка QLabel

Импорт из модуля PySide6.QtCore класса модели двухмерной модели QStandardItemModel,
класса иконок QIcon, класса стандартного элемента модели QStandardItem

Импорт из модуля PySide6.QtCore класса модели управления выделением

Импорт модуля для работы с переменными среды os
"""


class MainWindow(QMainWindow):
    """
    Класс главного окна приложения от супер класса главных окон
    """

    def __init__(self, parent=None) -> None:
        """
        Конструктор главного окна приложения
        :param parent: ссылка на родительский объект, объект верхнего уровня
        """
        super().__init__(parent)  # вызов конструктора родительского класса через функцию super()
        # QMainWindow.__init__(self, parent)  # явный вызов конструктора родительского класса
        self.setWindowTitle('Модель управления выделением')  # установка заголовка главного окна
        self.resize(500, 600)  # установка исходного размера главного окна
        self.table_view_1 = QTableView()  # создание экземпляра табличного представления
        self.table_view_2 = QTableView()  # создание экземпляра табличного представления
        self.table_model = QStandardItemModel()  # создание модели таблицы
        # создаем списки элементов строк таблицы
        lst_1 = ['Perl', 'РНР', 'Python', 'Ruby', 'C++']
        lst_2 = [' http://www.perl.org/', 'http://php.net/', 'https://www.python.org/',
                 'https://www.ruby-lang.org/', 'https://cplusplus.com/']
        lst_3 = [QIcon(os.path.join('data', 'perl.png')),
                 QIcon(os.path.join('data', 'php.png')),
                 QIcon(os.path.join('data', 'python.png')),
                 QIcon(os.path.join('data', 'ruby.png')),
                 QIcon(os.path.join('data', 'ruby.png'))]
        lst_4 = ['Перл', 'ПХП', 'Пайтон', 'Руби', 'Плюса']
        for name, link, ico, trans in zip(lst_1, lst_2, lst_3, lst_4):
            self.table_model.appendRow([QStandardItem(ico, ''),  # создаем экземпляры элементов модели
                                        QStandardItem(name),
                                        QStandardItem(link),
                                        QStandardItem(trans)])
        self.table_model.setHorizontalHeaderLabels(['Значок', 'Название', 'Сайт', 'Перевод'])  # задаем строку
        # заголовков столбцов
        self.table_view_1.setModel(self.table_model)  # присоединяем модель к представлению
        self.table_view_1.setColumnWidth(0, 50)  # задаем исходную ширину столбца
        self.table_view_1.setColumnWidth(2, 200)

        self.table_view_2.setModel(self.table_model)  # присоединяем модель к представлению
        self.table_view_2.setColumnWidth(0, 50)  # задаем исходную ширину столбца
        self.table_view_2.setColumnWidth(2, 200)

        self.selection_model = QItemSelectionModel(self.table_model)  # создаем модель управления выделением
        # с подключение модели данных
        self.table_view_1.setSelectionModel(self.selection_model)  # подключение модели выделения к представлению
        self.table_view_2.setSelectionModel(self.selection_model)
        self.selection_model.currentChanged.connect(lambda prev, cur: print(prev, cur))  # сигнал на изменение выделения
        # и его обработчик

        self.vbox = QVBoxLayout()  # создание вертикальной стопки для виджетов
        self.vbox.addWidget(QLabel('Первое представление'))  # добавление ярлыка с надписью
        self.vbox.addWidget(self.table_view_1)  # добавление представления в стопку
        self.vbox.addWidget(QLabel('Второе представление'))
        self.vbox.addWidget(self.table_view_2)

        self.container = QWidget()  # создание контейнера для слоев с виджетами
        self.container.setLayout(self.vbox)  # размещение слоя в контейнере
        self.setCentralWidget(self.container)  # размещение контейнера в главном окне приложения


if __name__ == '__main__':  # проверка условия запуска для предотвращения исполнения
    # кода верхнего уровня при импортировании данного файла как модуля
    from PySide6.QtWidgets import QApplication
    import sys

    """
    Импорт из модуля PySide6.QtWidgets класса управления приложением QApplication
    Импорт модуля sys, предоставляющего доступ к объекта интерпретатора, нужен для доступа
    к аргументам командной строки. Если использование аргументов командной строки не предполагается,
    то импорт можно не выполнять. При этом, при создании приложения в класс QtWidgets.QApplication([])
    в качестве аргумента передается пустой.
    """
    app = QApplication(sys.argv)  # создание основного цикла событий приложения
    app.setStyle('Fusion')  # установка более красивого стиля оформления графического интерфейса
    window = MainWindow()  # создание главного окна приложения
    window.show()  # включение видимости окна, по умолчанию окно спрятано
    sys.exit(app.exec())  # Запуск основного цикла событий приложения.
    # Код ниже метода запуска цикла событий не будет достигнут и выполнен пока не будет выполнен
    # выход и цикл событий не будет остановлен. Не обязательно оборачивать запуск цикла в метод sys.exit()

