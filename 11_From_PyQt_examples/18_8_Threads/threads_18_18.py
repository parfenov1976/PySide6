"""
Пример блокировщика доступа к ресурсу при его использовании одним потоком, для ресурсов
не поддерживающих одновременный доступ. В данном примере использован автоблокировщик
"""

import sys

from PySide6.QtWidgets import (QApplication,
                               QMainWindow,
                               QPushButton,
                               )
from PySide6.QtCore import (QThread,
                            QMutex,
                            QMutexLocker,
                            )

"""
Импорт модуля sys, предоставляющего доступ к объекта интерпретатора, нужен для доступа
к аргументам командной строки. Если использование аргументов командной строки не предполагается,
то импорт можно не выполнять. При этом, при создании приложения в класс QtWidgets.QApplication([])
в качестве аргумента передается пустой.

Импорт из модуля PySide6.QWidgets класса управления приложением QApplication, класса главного окна QMainWindow
класса виджета кнопки QPushButton

Импорт из модуля PySide6.QtCore класса потоков QThread, класс блокировщика ресурса QMutex,
класса автоблокировщика QMutexLocker 
"""


class MyThread(QThread):
    """
    Класс потока с кодом на выполнение от супер класса потоков
    """
    x = 10  # аттрибут класса в качестве ресурса, доступ к которому должен иметь только один поток
    mutex = QMutex()  # создание экземпляра блокировщика и сохранение его в аттрибут класса

    def __init__(self, id: int, parent: object = None) -> None:
        """
        Конструктор потока
        :param id: int - идентификатор потока
        :param parent: object - ссылка на родительский объект
        """
        QThread.__init__(self, parent)  # явный вызов конструктора родительского класса
        self.id = id  # создание аттрибута объекта для хранения идентификатора потока
        self.parent = parent

    def run(self) -> None:
        """
        Метод, содержащий код для выполнения в отдельном потоке
        :return: None
        """
        self.change_x()  # вызов метода, изменяющего ресурс, размещенный в аттрибуте класса

    def change_x(self) -> None:
        """
         Метод, получающий доступ к ресурсу на изменение
        :return: None
        """
        ml = QMutexLocker(MyThread.mutex)  # создаем экземпляр автоблокировщика и тем самым накладываем блокировку
        # на ресурс, представленный в виде аттрибута x класса MyThread
        print(f'x ={MyThread.x} id ={self.id}')  # вывод состояния ресурса и id потока, который имеет к нему доступ
        MyThread.x += 5  # изменение ресурса
        self.sleep(2)  # эмуляция вычислительной нагрузки
        print(f'x ={MyThread.x} id ={self.id}')  # вывод состояния ресурса и id потока, который имеет к нему доступ
        MyThread.x += 34  # изменение ресурса
        print(f'x ={MyThread.x} id ={self.id}')  # вывод состояния ресурса и id потока, который имеет к нему доступ
        # по достижении конца кода данного метода локальная переменная с автоблокировщиком будет уничтожена
        # сборщиком мусора вследствие чего блокировка будет снята


class MainWindow(QMainWindow):
    """
    Класс главного окна приложения от супер класса главных окон
    """

    def __init__(self, parent: object = None) -> None:
        """
        Конструктор главного окна приложения
        :param parent: object - ссылка на родительский объект
        """
        QMainWindow.__init__(self, parent)  # явный вызов конструктора родительского класса
        self.setWindowTitle('Использование блокировщика')  # установка названия главного окна
        self.btn = QPushButton('Запустить')  # создание кнопки для запуска выполнения потоков
        self.thread1 = MyThread(1)  # создание экземпляра потока 1
        self.thread2 = MyThread(2)  # создание экземпляра потока 2
        self.btn.clicked.connect(self.on_start)  # назначение обработчика сигналу на нажатие
        # кнопки запуска потоков на выполнение
        self.setCentralWidget(self.btn)  # размещение контейнера со слоями в главном окне приложения

    def on_start(self) -> None:
        """
        Метод запуска выполнения потоков на выполнение
        :return: None
        """
        if not self.thread1.isRunning():  # проверка - выполняется ли поток 1
            self.thread1.start()  # запуск потока 1 на выполнение
        if not self.thread2.isRunning():  # проверка - выполняется ли поток 1
            self.thread2.start()  # запуск потока 1 на выполнение


if __name__ == '__main__':  # проверка условия запуска модуля, предотвращающая
    # запуск кода верхнего уровня при импортировании данного файла как модуля
    app = QApplication(sys.argv)  # создание главного цикла событий (основного потока) главного окна приложения
    app.setStyle('Fusion')  # установка более красивой темы (стиля) для графического интерфейса
    window = MainWindow()  # создание экземпляра главного окна приложения
    window.resize(300, 30)  # установка исходного размера окна
    window.show()  # Метод для вывода главного окна приложения. По умолчанию окно спрятано.
    sys.exit(app.exec())  # Запуск основного цикла событий главного окна приложения.
    # Код ниже метода запуска цикла событий не будет достигнут и выполнен пока не будет выполнен
    # выход и цикл событий не будет остановлен. Не обязательно оборачивать запуск цикла в метод sys.exit()
