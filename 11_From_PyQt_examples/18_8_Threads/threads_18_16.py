"""
Пример много поточного приложения с использованием очереди заданий при ограниченном числе потоков
В данном примере создается два потока и очередь без ограничения количества элементов, в которую помещаем 11 элементов
"""

import sys

from PySide6.QtWidgets import (QApplication,
                               QMainWindow,
                               QPushButton,
                               QPlainTextEdit,
                               QVBoxLayout,
                               QWidget,
                               )
from PySide6.QtCore import (QThread,
                            Signal,
                            Qt,
                            )
from queue import Queue

"""
Импорт модуля sys, предоставляющего доступ к объекта интерпретатора, нужен для доступа
к аргументам командной строки. Если использование аргументов командной строки не предполагается,
то импорт можно не выполнять. При этом, при создании приложения в класс QtWidgets.QApplication([])
в качестве аргумента передается пустой.

Импорт из модуля PySide6.QWidgets класса управления приложением QApplication,
класса главных окон QMainWindow, класса кнопок QPushButton,
класса контейнера с вертикальным расположение виджетов QVBoxLayout,
класса многострочного текстового поля QPlainTextEdit,
класса слоев с вертикальной организацией виджетов QVBoxLayout,
базовый класс пустого виджета QWidget

Импорт из модуля PySide6.QtCore класса потоков QThread, класса набора аттрибутов и настроек Qt

Импорт из модуля для работы с очередями queue класса обычной очереди Queue
"""


class MyThread(QThread):
    """
    Класс потока от супер класса потоков
    """

    task_done = Signal(int, int, name='task_done')

    # создание сигнала о завершении задания в очереди,
    # который принимает результаты обработки задания, id потока и имя сигнала

    def __init__(self, id: int, queue: Queue, parent: object = None) -> None:
        """
        Конструктор потока
        :param id: int - идентификатор потока
        :param queue: Queue - ссылка на очередь
        :param parent: object - ссылка на родительский объект для потока
        :return: None
        """
        QThread.__init__(self, parent)  # явный вызов конструктора родительского класса
        self.id = id  # сохранение id потока в аттрибуте экземпляра потока
        self.queue = queue  # сохранение ссылки на объект очереди в аттрибуте экземпляра потока
        self.running = True  # создание флага выполнения

    def run(self) -> None:
        """
        Метод, содержащий код для выполнения в потоке
        """
        while self.running:  # запуск бесконечного цикла выполнения потока с проверкой флага выполнения
            task = self.queue.get()  # извлечение задания (данных для обработки) из очереди
            self.sleep(3)  # эмуляция нагрузки при обработке задания
            self.task_done.emit(task, self.id)  # генерация сигнала о завершении обработки задания
            # с передачей результата и идентификатора потока, который выполнял обработку
            self.queue.task_done()  # вызов встроенного метода очереди при завершении задания из очереди


class MainWindow(QMainWindow):
    """
    Класс главного окна приложения от супер класса главных окон
    """

    def __init__(self, parent: object = None) -> None:
        """
        Конструктор главного окна приложения
        """
        QMainWindow.__init__(self, parent)  # явный вызов конструктора родительского класса
        self.setWindowTitle('Использование очереди')  # установка заголовка главного окна приложения
        self.btn_task = QPushButton('Раздать задания')  # создание кнопки для запуска выполнения заданий из очереди
        self.queue = Queue()  # создание экземпляра очереди для заданий
        self.threads = []  # создание списка для сохранения потоков
        for i in range(1, 3):  # цикл для создания потоков
            thread = MyThread(i, self.queue)  # создание потока с передачей ссылки на очередь и идентификатора
            self.threads.append(thread)  # сохранение ссылки на поток в списке потоков
            thread.task_done.connect(self.on_task_done, Qt.ConnectionType.QueuedConnection)  # назначение слота
            # обработчика сигналу о завершении задания с указанием, что сигнал помещается в очередь обработки
            # событий и обработчик должен выполняться в основном потоке приложения
            thread.start()  # запуск потока на выполнение
        self.btn_task.clicked.connect(self.on_add_task)  # назначение слота обработчика сигналу на нажатие кнопки
        self.txt = QPlainTextEdit()  # создание многострочного текстового поля
        self.txt.setReadOnly(True)  # установка запрета на редактирование текста в поле
        self.vbox = QVBoxLayout()  # создание слоя для виждетов с вертикальной организацией
        self.vbox.addWidget(self.txt)  # добавление текстового поля на слой
        self.vbox.addWidget(self.btn_task)  # добавление кнопки на слой
        self.widget = QWidget()  # создание контейнера для слоя с виджетами
        self.widget.setLayout(self.vbox)  # размещение слоя с виджетами в контейнере
        self.setCentralWidget(self.widget)  # размещение контейнера в главном окне приложения

    def on_add_task(self):
        """
        Слот обработчик сигнала кнопки для добавления заданий
        """
        for i in range(0, 11):  # цикл формирования очереди заданий
            self.queue.put(i)  # добавление задания в очередь

    def on_task_done(self, data: int, id: int) -> None:
        """
        Слот обработчик сигнала о завершении выполнения задания потоком, выводящий результаты работы
        :param data: int - обработанные данные
        :param id: int - идентификатор потока
        :return: None
        """
        self.txt.appendPlainText(f'{data} - id = {id}')
        print(f'{data} - id = {id}')

    def closeEvent(self, event: QMainWindow.closeEvent) -> None:
        """
        Обработчик события, вызываемый при закрытии окна
        """
        self.hide()  # прячем главного окно приложения
        for thread in self.threads:  # цикл остановки потоков
            thread.running = False  # меняем флаг выполнения
            thread.wait(5000)  # выделяем время на завершение потока
        event.accept()  # закрываем окно приложения


if __name__ == '__main__':  # проверка условия запуска модуля предотвращает запуск кода после условия при
    # импортировании данного файла как модуля
    app = QApplication(sys.argv)  # создание основного цикла событий (основного потока) главного окна приложения
    app.setStyle('Fusion')  # более интересная глобальная кроссплатформенна тема Fusion
    window = MainWindow()  # создание экземпляра главного окна приложения
    window.resize(300, 300)  # установка размеров окна по умолчанию
    window.show()  # Метод для вывода главного окна. По умолчанию окно спрятано.
    sys.exit(app.exec())  # Запуск основного цикла событий главного окна приложения.
    # Код ниже метода запуска цикла событий не будет достигнут и выполнен пока не будет выполнен
    # выход и цикл событий не будет остановлен. Не обязательно оборачивать запуск цикла в метод sys.exit()
