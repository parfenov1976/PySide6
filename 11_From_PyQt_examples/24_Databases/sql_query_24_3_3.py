"""
Очистка запроса

После первого выполнения метода exec() или execBatch() запрос переходит в активное
состояние, и выполнить любую другую SQL-команду с его помощью станет невозможно.
Метод isActive() класса QSqlQuery возвращает True, если запрос находится в активном
состоянии. Если же запрос неактивен, метод возвращает False.
Если один и тот же объект класса QSqlQuery планируется использовать для выполнения
нескольких SQL-команд, перед выполнением новой команды следует сбросить его, переведя
тем самым в неактивное состояние и освободив занимаемые им системные ресурсы. Это
выполняется вызовом метода clear():
query = QtSql.QSqlQuery()
query.exec("select * from good order bу goodname") # Обрабатываем результат запроса
query.clear()
query.exec("select count(*) as cnt from good")
# Работаем с новым запросом
"""

from PySide6.QtWidgets import (QMainWindow,
                               QPlainTextEdit,
                               )
from PySide6.QtSql import QSqlDatabase, QSqlQuery

"""
Импорт из модуля PySide6.QtWidgets класса главных окон QMainWindow, 
класса многострочного редактируемого текстового поля для простого текста QPlainTextEdit

Импорт из модуля PySide6.QtSql класса соединений с базами данных QSqlDatabase,
класса запросов QSqlQuery
"""


class MainWindow(QMainWindow):
    """
    Класс главного окна приложения от супер класса главных окон
    """

    def __init__(self, parent=None) -> None:
        """
        Конструктор главного окна приложения
        """
        QMainWindow.__init__(self, parent)  # явный вызов конструктора родительского класса
        self.setWindowTitle('Получение данных о таблицах базы данных')  # установка заголовка главного окна приложения
        self.resize(600, 600)  # установка исходного размера окна
        self.txt_field = QPlainTextEdit()  # создание многострочного текстового поля
        self.setCentralWidget(self.txt_field)  # размещение текстового поля в главном окне приложения

    def append_txt(self, txt: str) -> None:
        """
        Метод добавления текста в текстовое поле
        :param txt: str - текст для добавления в поле
        """
        self.txt_field.appendPlainText(txt)  # добавление текста


def main() -> None:
    """
    Код примера выполнения запроса и его очистки
    :return: None
    """
    sqlite_con = QSqlDatabase.addDatabase('QSQLITE')  # создание объекта соединения с базой данных
    sqlite_con.setDatabaseName('data.sqlite')  # подключение базы данных
    sqlite_con.open()  # открытие базы данных

    # Первый запрос и обработка его результатов
    query = QSqlQuery()  # создание объекта запроса
    query.exec('SELECT * FROM good ORDER BY goodname')  # выполнение запроса на выборку данных
    lst = []  # создание списка для сохранения результатов запроса
    if query.isActive():  # проверка активности запроса
        query.first()  # позиционирование указателя запроса на первую запись результата
        while query.isValid():  # выполнять пока указатель указывает на какую-либо запись
            lst.append(f'{query.value('goodname')}: {str(query.value('goodcount'))} шт.')  # формирование строки
            # по данным записи и сохранение в список для результатов
            query.next()  # позиционирование указателя на следующую запись
        for item in lst:  # вывод списка с результатами в текстовое поле
            window.append_txt(item)

    # проверка активности первого запроса
    window.append_txt(f'\nЗапрос активен: {query.isActive()}')

    # очистка запроса
    query.clear()
    window.append_txt(f'\nСостояние активности запроса после очистки: {query.isActive()}')

    # новый запрос
    query.exec('SELECT COUNT(*) AS CNT FROM good')  # выполнение запроса на подсчет количества строк
    query.first()  # позиционирование указателя запроса на первую запись результата
    window.append_txt(f'\nДанные о результатах нового запроса запроса{query.record()}')
    window.append_txt(f'\nКоличество строк в таблице {query.value('CNT')}')  # вывод значения поля из результата запроса
    window.append_txt(f'\nСостояние активности нового запроса: {query.isActive()}')

    sqlite_con.close()  # закрытие базы данных


if __name__ == '__main__':  # проверка условия запуска для предотвращения исполнения
    # кода верхнего уровня при импортировании данного файла как модуля
    from PySide6.QtWidgets import QApplication
    import sys

    """
    Импорт из модуля PySide6.QtWidgets класса управления приложением QApplication
    Импорт модуля sys, предоставляющего доступ к объекта интерпретатора, нужен для доступа
    к аргументам командной строки. Если использование аргументов командной строки не предполагается,
    то импорт можно не выполнять. При этом, при создании приложения в класс QtWidgets.QApplication([])
    в качестве аргумента передается пустой.
    """
    app = QApplication(sys.argv)  # создание основного цикла событий приложения
    app.setStyle('Fusion')  # установка более красивого стиля оформления графического интерфейса
    window = MainWindow()  # создание главного окна приложения
    window.show()  # включение видимости окна, по умолчанию окно спрятано
    main()  # запуск функции с кодом верхнего уровня
    sys.exit(app.exec())  # Запуск основного цикла событий приложения.
    # Код ниже метода запуска цикла событий не будет достигнут и выполнен пока не будет выполнен
    # выход и цикл событий не будет остановлен. Не обязательно оборачивать запуск цикла
