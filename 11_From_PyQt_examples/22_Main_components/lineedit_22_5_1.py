"""
Основные компоненты интерфейса. Поле ввода, основные методы и сигналы.

Поле ввода самостоятельно поддерживает технологию drag & drop, стандартные комбинации
клавиш быстрого доступа, работу с буфером обмена и многое другое. Оно реализуется
классом QLineEdit. Иерархия наследования:
(QObject, QPaintDevice) - QWidget - QLineEdit
Конструктор класса QLineEdit имеет два формата:
QLineEdit([parent=None]) QLineEdit(<Текст>[, parent=None])
В параметре parent указывается ссылка на родительский компонент. Если родитель не
указан или имеет значение None, компонент будет обладать своим собственным окном. Параметр
<Текст> позволяет задать текст, который будет отображен в поле ввода.

Класс QLineEdit поддерживает следующие методы (полный их список смотрите на странице
https://doc.qt.io/qt-6/qlineedit.html):
♦ setText(<Текст>) - помещает указанный текст в поле ввода. Метод является слотом;
♦ insert(<Текст>) - вставляет текст в текущую позицию текстового курсора. Если в поле
  ввода был выделен фрагмент, он будет удален;
♦ text() - возвращает текст, содержащийся в поле ввода;
♦ displayText() - возвращает текст, который видит пользователь. Результат зависит от
  режима отображения, заданного с помощью метода setEchoMode() (например, в режиме
  Password строка будет состоять из звездочек);
♦ clear() - удаляет весь текст из поля. Метод является слотом;
♦ backspace() - удаляет выделенный фрагмент. Если выделенного фрагмента нет, удаляет
  символ, стоящий слева от текстового курсора;
♦ del() - удаляет выделенный фрагмент. Если выделенного фрагмента нет, удаляет символ,
  стоящий справа от текстового курсора;
♦ setSelection(<Индекс>, <Длина>) - выделяет фрагмент длиной <Длина>, начиная с позиции
  <Индекс>. Во втором параметре можно указать отрицательное значение;
♦ selectedText() - возвращает выделенный фрагмент или пустую строку, если ничего не выделено;
♦ selectAll() - выделяет весь текст в поле. Метод является слотом;
♦ selectionStart()· - возвращает начальный индекс выделенного фрагмента или значение -1,
  если ничего не выделено;
♦ selectionEnd() - возвращает индекс символа, следующего сразу за последним символом
  выделенного фрагмента, или значение -1, если ничего не выделено;
♦ hasSelectedText() - возвращает значение True, если поле ввода содержит выделенный
  фрагмент, и False - в противном случае;
♦ deselect() - снимает выделение;
♦ isModified() - возвращает True, если текст в поле был изменен пользователем, и False
  - в противном случае. Отметьте, что вызов метода setText() помечает поле как неизмененное;
♦ setModified(<Флаг>) - если передано значение True, поле ввода помечается как измененное,
  если False - как неизмененное;
♦ setEchoMode(<Режим>) - задает режим отображения текста. Могут быть указаны следующие
  элементы перечисления EchoMode из класса QLineEdit:
  • Normal - показывать вводимые символы;
  • NoEcho - не показывать вводимые символы;
  • Password - вместо символов выводить звездочки (*);
  • PasswordEchoOnEdit - показывать символы при вводе, а после потери фокуса вместо них
    отображать звездочки;
♦ setCompleter(<Список>) - задает список вариантов значений для автозавершения.
  В качестве параметра указывается объект класса QCompleter. Пример:
  lineEdit = QtWidgets.QLineEdit()
  arr = ["кадр", "каменный", "камень", "камера"]
  completer = QtWidgets.QCompleter(arr, parent=window)
  lineEdit.setCompleter(completer)
♦ setReadOnly(<Флаг>) - если в качестве параметра указано значение True, поле будет
  доступно только для чтения;
♦ isReadOnly() - возвращает значение True, если поле доступно только для чтения, и
  False - в противном случае;
♦ setAlignment(<Выравнивание AlignmentFlag>) - задает выравнивание текста внутри
  поля;
♦ setMaxLength(<Количество>) - задает максимальную длину вводимого значения в символах;
♦ setFrame(<Флаг>) - если в качестве параметра указано значение False, поле будет
  отображаться без рамки;
♦ setDragEnabled(<Флаг>) - если в качестве параметра указано значение True, режим
  перетаскивания текста из текстового поля с помощью мыши будет включен. По умолчанию
  поле ввода только принимает перетаскиваемый текст;
♦ setPlaceholderText(<Текст>) - задает текст подсказки, который будет выводиться
  непосредственно в поле ввода, когда оно не содержит значения и не имеет фокуса ввода;
♦ setTextMargins() - задает величины отступов от границ компонента до находящегося в
  нем текста. Форматы метода:
  setTextMargins(<Слева>, <Сверху>, <Справа>, <Снизу>)
  setTextMargins(<Отступы QMargins>)
♦ setCursorPosition(<Индекс>) - задает положение текстового курсора;
♦ cursorPosition() - возвращает текущее положение текстового курсора;
♦ cursorForward(<Флаг>[, steps=1]) - перемещает текстовый курсор вперед на указанное
  во втором параметре количество символов. Если в первом параметре указано значение
  True, выполняется выделение фрагмента;
♦ cursorBackward(<Флаг>[, steps=1]) - перемещает текстовый курсор назад на указанное
  во втором параметре количество символов. Если в первом параметре указано значение
  True, выполняется выделение фрагмента;
♦ cursorWordForward(<Флаг>) - перемещает текстовый курсор вперед на одно слово. Если
  в параметре указано значение True, выполняется выделение фрагмента;
♦ cursorWordBackward(<Флаг>) - перемещает текстовый курсор назад на одно слово. Если
  в параметре указано значение True, выполняется выделение фрагмента;
♦ home(<Флаг>) - перемещает текстовый курсор в начало поля. Если в параметре указано
  значение True, выполняется выделение фрагмента;
♦ end(<Флаг>) - перемещает текстовый курсор в конец поля. Если в параметре указано
  значение True, выполняется выделение фрагмента;
♦ cut() - вырезает выделенный текст в буфер обмена при условии, что есть выделенный
  фрагмент и используется режим Normal. Метод является слотом;
♦ сору() - копирует выделенный текст в буфер обмена при условии, что есть выделенный
  фрагмент и используется режим Normal. Метод является слотом;
♦ paste() - вставляет текст из буфера обмена в текущую позицию текстового курсора
  при условии, что поле доступно для редактирования. Метод является слотом;
♦ undo() - отменяет последнюю операцию ввода пользователем при условии, что отмена
  возможна. Метод является слотом;
♦ redo() - повторяет последнюю отмененную операцию ввода пользователем, если это
  возможно. Метод является слотом;
♦ isUndoAvailable() - возвращает значение True, если можно отменить последнюю операцию
  ввода, и False - в противном случае;
♦ isRedoAvailable() - возвращает значение True, если можно повторить последнюю
  отмененную операцию ввода, и False - в противном случае;
♦ createStandardContextMenu() - создает стандартное контекстное меню, которое отображается
  при щелчке правой кнопкой мыши в текстовом поле. Чтобы изменить стандартное меню,
  следует создать класс, производный от QLineEdit, и переопределить в нем метод
  contextMenuEvent(self, <event>). Внутри этого метода можно создать свое собственное
  меню или добавить новый пункт в стандартное меню;
♦ setClearButtonEnabled(<Флаг>) - если передано True, в правой части непустого поля
  будет выводиться кнопка, нажатием которой можно очистить это поле, если False, кнопка
  очистки выводиться не будет.
Класс QLineEdit поддерживает следующие сигналы:
♦ cursorPositionChanged(<Старая позиция>, <Новая позиция>) - генерируется при
  перемещении текстового курсора. Внутри обработчика через первый параметр доступна
  старая позиция курсора, а через второй параметр - новая позиция. Оба параметра являются
  целочисленными;
♦ editingFinished() - генерируется при нажатии клавиши <Enter> или потере полем фокуса ввода;
♦ inputRejected() - генерируется, если операция ввода, выполненная пользователем, отвергнута
  полем ввода. Это может случиться, например, при попытке ввести значение с длиной большей,
  чем задана вызовом метода setMaxLength();
♦ returnPressed() - генерируется при нажатии клавиши <Enter>;
♦ selectionChanged() - генерируется при изменении выделения;
♦ textChanged(<Новый текст>) - генерируется при изменении текста внутри поля пользователем
  или программно. Внутри обработчика через параметр доступен новый текст в виде строки;
♦ textEdited(<Новый текст>) - генерируется при изменении текста внутри поля пользователем.
  При задании текста вызовом метода setText() не генерируется. Внутри обработчика через
  параметр доступен новый текст в виде строки.
"""
from PySide6.QtWidgets import (QMainWindow,
                               QLineEdit,
                               QLabel,
                               QGridLayout,
                               QPushButton,
                               QWidget,
                               )
from PySide6.QtCore import Qt

"""
Импорт из модуля PySide6.QtWidgets класса главного окна приложения QMainWindow,
класса однострочного редактируемого текстового поля QLineEdit, класса контейнера-сетки QGridLayout,
класса виджета ярлыка QLabel, класса виджета кнопки QPushButton, базового класса пустого виджета QWidget

Импорт из модуля PySide6.QtCort класса перечислителя настроек виджетов Qt
"""


class MainWindow(QMainWindow):
    """
    Класс главного окна приложения от класса главных окон
    """

    def __init__(self, parent=None):
        """
        Конструктор главного окна приложения
        """
        QMainWindow.__init__(self, parent)  # явный вызов конструктора родительского класса
        self.resize(450, 300)  # установка исходного размера окна
        self.setWindowTitle('Поле ввода')  # установка заголовка главного окна приложения
        self.grid = QGridLayout()  # создание контейнера сетки для размещения виджетов

        self.lbl_1 = QLabel('Текстовое поле обычное')  # создание ярлыка с надписью
        self.line_edit_1 = QLineEdit('Текст в поле')  # создание редактируемого текстового поля
        self.line_edit_1.setAlignment(Qt.AlignmentFlag.AlignCenter)  # настройка выравнивания в поле
        self.lbl_btn = QLabel('Двигать курсор')  # создание ярлыка с надписью
        self.lbl_btn.setAlignment(Qt.AlignmentFlag.AlignCenter)  # установка настроек выравнивания
        self.btn_left = QPushButton('<<')  # создание кнопки
        self.btn_right = QPushButton('>>')  # создание кнопки
        self.line_edit_1.setCursorPosition(len(self.line_edit_1.text()) // 2)  # центровка курсора в поле
        self.btn_left.clicked.connect(lambda: self.line_edit_1.cursorBackward(True))  # привязка обработчика
        self.btn_right.clicked.connect(lambda: self.line_edit_1.cursorForward(True))  # привязка обработчика

        self.lbl_2 = QLabel('Текстовое поле для пароля')  # создание ярлыка с надписью
        self.line_edit_2_1 = QLineEdit()  # создание текстового поля
        self.line_edit_2_2 = QLineEdit()
        self.line_edit_2_1.setEchoMode(QLineEdit.EchoMode.Password)  # установка режима отображения вводимого текста
        self.line_edit_2_1.setPlaceholderText('Введите пароль')  # установка текста подсказки в текстовое поле
        self.line_edit_2_2.setReadOnly(True)  # установка текстового поля в режим только для чтения
        self.line_edit_2_1.textEdited.connect(self.text_edited)  # создание сигнала на редактирование текстового поля
        # и привязка обработчика

        # размещение элементов интерфейса в сетке
        self.grid.addWidget(self.lbl_1, 0, 0)
        self.grid.addWidget(self.line_edit_1, 0, 1, 1, 2)
        self.grid.addWidget(self.btn_left, 1, 0)
        self.grid.addWidget(self.lbl_btn, 1, 1)
        self.grid.addWidget(self.btn_right, 1, 2)
        self.grid.addWidget(self.lbl_2, 2, 0)
        self.grid.addWidget(self.line_edit_2_1, 2, 1)
        self.grid.addWidget(self.line_edit_2_2, 2, 2)

        self.container = QWidget()  # создание контейнера для слоев с виджетами
        self.container.setLayout(self.grid)  # размещение сетки в контейнере для слоев
        self.setCentralWidget(self.container)  # размещение контейнера со слоями в главном окне приложения

    def text_edited(self, new_text: str) -> None:
        """
        Обработчик сигнала на редактирование текста в поле
        """
        self.line_edit_2_2.setText(new_text)  # размещение текста в текстовом поле


if __name__ == '__main__':  # проверка условия запуска данного файла для предотвращения запуска кода верхнего уровня
    # при импортировании данного файла как модуля
    import sys
    from PySide6.QtWidgets import QApplication

    """
    Импорт модуля sys, предоставляющего доступ к объекта интерпретатора, нужен для доступа
    к аргументам командной строки. Если использование аргументов командной строки не предполагается,
    то импорт можно не выполнять. При этом, при создании приложения в класс QtWidgets.QApplication([])
    в качестве аргумента передается пустой.
    Импорт из модуля PySide6.QWidgets класса управления приложением QApplication.
    """
    app = QApplication(sys.argv)  # создание основного цикла событий приложения
    app.setStyle('Fusion')  # установка более красивого стиля графического интерфейса
    window = MainWindow()  # создание главного окна приложения
    window.show()  # вывод окна на экран, по умолчанию окно спрятано
    sys.exit(app.exec())  # Запуск основного цикла событий приложения.
    # Код ниже метода запуска цикла событий не будет достигнут и выполнен пока не будет выполнен
    # выход и цикл событий не будет остановлен. Не обязательно оборачивать запуск цикла в метод sys.exit()
