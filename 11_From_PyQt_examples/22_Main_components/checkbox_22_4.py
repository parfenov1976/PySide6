"""
Основные компоненты интерфейса. Флажок.

Флажок может находиться в нескольких состояниях: установленном, сброшенном и промежуточном
(неопределенном) - последнее состояние может быть запрещено программно.
Флажок реализуется с помощью класса QCheckBox. Иерархия наследования:
(QObject, QPaintDevice) - QWidget - QAbstractButton - QCheckBox
Конструктор класса QCheckBox имеет два формата:
QCheckBox([parent=None])
QCheckBox(<Текст> [, parent=None])
Класс QCheckBox наследует все методы класса QAbstractButton (здесь приведены
только основные - полный их список смотрите на странице https://doc.qt.io/qt-6/
qabstractbutton.html):
♦ setText(<Текст>) - задает текст, который будет отображен на кнопке. Внутри текста
  символ &, указанный перед буквой или цифрой, задает комбинацию клавиш быстрого
  доступа. В этом случае буква, перед которой указан символ &, будет - в качестве подсказки
  пользователю - подчеркнута. Одновременное нажатие клавиши <Alt> и подчеркнутой
  буквы приведет к нажатию этой кнопки. Чтобы вывести сам символ &, необходимо
  его удвоить;
♦ text() - возвращает текст, отображаемый на кнопке;
♦ setShortcut(<Клавиша QKeySequence>) - задает клавишу быстрого доступа:
  button.setShortcut("Alt+B")
  button.setShortcut(QtGui.QKeySequence.mnemonic("&B"))
  button.setShortcut(QtGui.QKeySequence("Alt+B"))
  button.setShortcut(QtGui.QKeySequence(QtCore.Qt.Key.Key_F5))
♦ setIcon(<Значок QIcon>) - вставляет значок перед текстом кнопки;
♦ setIconSize(<Размеры QSize>) - задает размеры значка. Метод является слотом;
♦ setAutoRepeat(<Флаг>) - если в качестве параметра указано значение True, сигнал
  clicked будет периодически генерироваться, пока кнопка находится в нажатом состоянии;
♦ animateClick() - имитирует нажатие пользователем кнопки с анимацией. После нажатия
  кнопка находится в этом состоянии в течении 100 миллисекунд. Метод является слотом;
♦ click() - имитирует нажатие кнопки без анимации. Метод является слотом;
♦ setCheckable(<Флаг>) - если в качестве параметра указано значение True, то кнопка
  является переключателем, который может находиться в двух состояниях: установленном
  и неустановленном;
♦ setChecked(<Флаг>) - если в качестве параметра указано значение True, кнопка переключатель
  будет находиться в установленном состоянии. Метод является слотом;
♦ isChecked() - возвращает значение True, если кнопка-переключатель находится в установленном
  состоянии, и False - в противном случае;
♦ toggle() - переключает кнопку-переключатель. Метод является слотом;
♦ setAutoExclusive(<Флаг>) - если в качестве параметра указано значение True, внутри
  контейнера может быть установлена только одна кнопка-переключатель;
♦ setDown(<Флаг>) - если в качестве параметра указано значение True, кнопка будет находиться
  в нажатом состоянии;
♦ isDown() - возвращает значение True, если кнопка находится в нажатом состоянии,
  и False - в противном случае.
Также QCheckBox добавляет несколько своих:
♦ setCheckState(<Состояние>) - задает состояние флажка. Могут быть указаны следующие
  элементы перечисления Checkstate из модуля QtCore.Qt:
  • unchecked - флажок сброшен;
  • PartiallyChecked - флажок находится в промежуточном состоянии;
  • Checked - флажок установлен;
♦ checkState() - возвращает текущее состояние флажка;
♦ setTristate([<Флаг>=True]) - если в качестве параметра указано· значение True (значение
  по умолчанию), флажок может находиться во всех трех состояниях. По умолчанию
  поддерживаются только установленное·и сброшенное состояния;
♦ isTristate() - возвращает значение True, если флажок поддерживает три состояния.
  и False - если только два.
Чтобы перехватить изменение состояния флажка, следует назначить обработчик сигнала
stateChanged (<Состояние>). Через параметр внутри обработчика доступно новое состояние
флажка, заданное в виде целого числа: О (сброшенное), 1 (промежуточное) или 2 (установленное).
Если используется флажок, поддерживающий только два состояния, установить или сбросить
его позволяет метод setChecked (), а проверить текущее состояние - метод isChecked.
Обработать изменение состояния можно в обработчике сигнала toggled(<Состояние>)
параметр которого имеет логический тип.
"""
import os
from PySide6.QtWidgets import (QMainWindow,
                               QCheckBox,
                               QPlainTextEdit,
                               )
from PySide6.QtGui import QIcon

"""
Импорт из модуля PySide6.QtWidgets класс главного окна QMainWindow, 
класс виджета флажка QCheckBox,
класса многострочного редактируемого поля для текста QPlainTextEdit

Импорт из модуля PySide6.QtGui класса иконок QIcon
"""


class MainWindow(QMainWindow):
    """
    Класс главного окна приложения от супер класса главных окон
    """

    def __init__(self, parent=None) -> None:
        """
        Конструктор главного окна приложения
        :param parent:  ссылка на родительский компонент
        """
        QMainWindow.__init__(self, parent)  # явный вызов конструктора родительского класса
        self.setWindowTitle('Кнопка - QPushButton')  # установка заголовка главного окна приложения
        self.resize(400, 300)  # установка исходного размера главного окна
        self.txt_area = QPlainTextEdit(self)  # создание текстового поля
        self.txt_area.resize(150, 300)  # установка размера текстового поля
        self.txt_area.move(250, 0)  # указание смещения текстового поля в окне приложения

        self.checkbox_1 = QCheckBox('Флажок 1 с двумя состояниями', self)  # создание флажка
        self.checkbox_1.resize(200, 24)  # установка исходного размера
        self.checkbox_1.move(5, 0)  # смещение флажка
        self.checkbox_1.setChecked(True)  # установка исходного состояния
        self.checkbox_1.stateChanged.connect(self.state_change_1)  # назначение обработчика сигналу изменения
        # состояния флажка

        self.checkbox_2 = QCheckBox('Флажок 2 с тремя состояниями', self)  # создание флажка
        self.checkbox_2.resize(200, 24)  # установка исходного размера
        self.checkbox_2.move(5, 34)  # смещение флажка
        self.checkbox_2.setTristate(True)
        self.checkbox_2.stateChanged.connect(self.state_change_2)  # назначение обработчика сигналу изменения
        # состояния флажка

    def state_change_1(self, event: int) -> None:
        """
        Обработчика сигнала изменения состояния флажка
        :param event: int - код состояния флажка
        :return: None
        """
        self.txt_area.appendPlainText(f'Состояние флажка 1 {"сброшен" if event == 0 else "установлен"}')

    def state_change_2(self, event: int) -> None:
        """
        Обработчика сигнала изменения состояния флажка
        :param event: int - код состояния флажка
        :return: None
        """
        state = 0
        match event:
            case 0:
                state = 'сброшен'
            case 1:
                state = 'промежуточное'
            case 2:
                state = 'установлен'
        self.txt_area.appendPlainText(f'Состояние флажка 2 {state}')
        # state = {0: 'сброшен',
        #          1: 'промежуточное',
        #          2: 'установлен'}
        # self.txt_area.appendPlainText(f'Состояние флажка 2 {state[event]}')


if __name__ == '__main__':  # проверка условия запуска данного файла для предотвращения запуска кода верхнего уровня
    # при импортировании данного файла как модуля
    import sys
    from PySide6.QtWidgets import QApplication

    """
    Импорт модуля sys, предоставляющего доступ к объекта интерпретатора, нужен для доступа
    к аргументам командной строки. Если использование аргументов командной строки не предполагается,
    то импорт можно не выполнять. При этом, при создании приложения в класс QtWidgets.QApplication([])
    в качестве аргумента передается пустой.
    Импорт из модуля PySide6.QWidgets класса управления приложением QApplication.
    """
    app = QApplication(sys.argv)  # создание основного цикла событий приложения
    app.setStyle('Fusion')  # установка более красивого стиля графического интерфейса
    window = MainWindow()  # создание главного окна приложения
    window.show()  # вывод окна на экран, по умолчанию окно спрятано
    sys.exit(app.exec())  # Запуск основного цикла событий приложения.
    # Код ниже метода запуска цикла событий не будет достигнут и выполнен пока не будет выполнен
    # выход и цикл событий не будет остановлен. Не обязательно оборачивать запуск цикла в метод sys.exit()
