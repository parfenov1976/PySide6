"""
Использование таймеров

Таймеры позволяют через заданный интервал времени выполнять специальный метод timerEvent().
Для назначения таймера используется метод startTimer() компонента. Формат метода:
startTimer(<Интервал>[, timerType=TimerType.CoarseTimer])
Интервал времени задается в миллисекундах. Минимальное значение интервала зависит от
операционной системы. Если указать значение О, таймер будет срабатывать регулярно при
отсутствии других необработанных событий.
Необязательный параметр timerType задает тип таймера в виде одного из элементов перечисления
TimerType из модуля QtCore.Qt:
♦ PreciseTimer - точный таймер, обеспечивающий точность до миллисекунд;
♦ CoarseTimer - «приблизительный» таймер, обеспечивающий точность в пределах 5% от заданного
  интервала
♦ VeryCoarseTimer - «приблизительный» таймер, обеспечивающий точность до секунд.
Метод startTimer() возвращает идентификатор таймера, с помощью которого впоследствии можно
остановить таймер.
Формат специального метода timerEvent():
timerEvent(self, <Объект класса QTimerEvent>)
Внутри этого метода можно получить идентификатор таймера, вызвав метод timerid() у объекта класса
QTimerEvent, который передается методу timerEvent() со вторым параметром.
Чтобы остановить таймер с указанным идентификатором, необходимо воспользоваться методом
killTimer(<Идентификатор>) компонента.
"""
import sys
import time

from PySide6.QtWidgets import (QApplication,
                               QMainWindow,
                               QPushButton,
                               QLabel,
                               QVBoxLayout,
                               QWidget,
                               )
from PySide6.QtCore import Qt

"""
Импорт модуля sys, предоставляющего доступ к объекта интерпретатора, нужен для доступа
к аргументам командной строки. Если использование аргументов командной строки не предполагается,
то импорт можно не выполнять. При этом, при создании приложения в класс QtWidgets.QApplication([])
в качестве аргумента передается пустой.

Импорт из модуля PySide6.QWidgets класса управления приложением QApplication, класса главных окон QMainWindow,
класса виджета кнопки QPushButton, класс базового пустого виджета QWidget, класс ярлыка QLabel,
класса слоя для виджетов QVBoxLayout с вертикальной организацией

Импорт из модуля PySide6.QtCore класса класса аттрибутов для настройки и управления виджетами Qt. 
"""


class MainWindow(QMainWindow):
    """
    Класс главного окна приложения от супер класса главных окон
    """

    def __init__(self, parent=None) -> None:
        """
        Конструктор главного окна приложения
        :param parent: ссылка на родительский объект
        """
        QMainWindow.__init__(self, parent)  # явный вызов конструктора родительского класса
        self.setWindowTitle('Часы')  # присвоение заголовка главному окну приложения
        self.resize(200, 100)  # установка исходного размера главного окна
        self.timer_id = 0  # создание аттрибута для хранения идентификатора таймера
        self.lbl = QLabel('')  # создание виджета ярлыка для отображения часов
        self.lbl.setAlignment(Qt.AlignmentFlag.AlignHCenter)  # установка настроек выравнивания текста в ярлыке
        self.btn1 = QPushButton('Запустить')  # создание виджета кнопки запуска таймера
        self.btn2 = QPushButton('Остановить')  # создание виджета кнопки остановки таймера
        self.btn2.setEnabled(False)  # блокировка кнопки
        self.vbox = QVBoxLayout()  # создание слоя для виджетов
        self.vbox.addWidget(self.lbl)  # размещение ярлыка в слое для виджетов
        self.vbox.addWidget(self.btn1)  # размещение кнопки в слое для виджетов
        self.vbox.addWidget(self.btn2)  # размещение кнопки в слое для виджетов
        self.container = QWidget()  # создание контейнера для слоев с виджетами
        self.container.setLayout(self.vbox)  # размещение слоя с виджета в контейнере
        self.setCentralWidget(self.container)  # размещение контейнера со слоем для виджетов в главном окне приложения
        self.btn1.clicked.connect(self.on_clicked_btn1)  # создание сигнала на нажатие кнопки с привязкой обработчика
        self.btn2.clicked.connect(self.on_clicked_btn2)  # создание сигнала на нажатие кнопки с привязкой обработчика

    def on_clicked_btn1(self) -> None:
        """
        Обработчик сигнала на нажатие кнопки запуска таймера
        :return: None:
        """
        self.timer_id = self.startTimer(1000, timerType=Qt.TimerType.VeryCoarseTimer)
        # создаем приблизительный таймер с интервалом в 1000 мсек и записываем ссылку на него в аттрибут
        # для идентификатора таймера
        self.btn1.setEnabled(False)  # блокируем кнопку запуска таймера
        self.btn2.setEnabled(True)  # разблокируем кнопу остановки таймера

    def on_clicked_btn2(self) -> None:
        """
        Обработчика сигнала на нажатие кнопки остановки таймера
        :return: None:
        """
        if self.timer_id:  # проверка наличия ссылки на таймер в аттрибуте
            self.killTimer(self.timer_id)  # остановка таймера
            self.timer_id = 0  # очистка аттрибута для идентификатора таймера
            self.btn1.setEnabled(True)  # разблокируем кнопку запуска таймера
            self.btn2.setEnabled(False)  # блокируем кнопу остановки таймера

    def timerEvent(self, event: QMainWindow.timerEvent) -> None:
        """
        Обработчика событий таймера
        :param event: QMainWindow.timerEvent - событие таймера
        :return: None
        """
        self.lbl.setText(time.strftime('%H:%M:%S'))


if __name__ == '__main__':  # проверка условия запуска данного файла для предотвращения запуска кода верхнего уровня
    # при импортировании данного файла как модуля
    app = QApplication(sys.argv)  # создание основного цикла событий приложения
    app.setStyle('Fusion')  # установка более красивого стиля графического интерфейса
    window = MainWindow()  # создание главного окна приложения
    window.show()  # вывод окна на экран, по умолчанию окно спрятано
    sys.exit(app.exec())  # Запуск основного цикла событий приложения.
    # Код ниже метода запуска цикла событий не будет достигнут и выполнен пока не будет выполнен
    # выход и цикл событий не будет остановлен. Не обязательно оборачивать запуск цикла в метод sys.exit()
