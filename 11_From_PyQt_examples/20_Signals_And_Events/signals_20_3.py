"""
Пример создания пользовательского слота

Любой пользовательский метод можно сделать слотом, для чего необходимо перед его
определением вставить декоратор @pyqtSlot(). Формат декоратора:
@QtCore.pyqtSlot([<Tип 1>, <Тип 2>, . . . , <Тип N>] [, name=None] [, result=None])
Можно указать типы параметров, принимаемых слотом (bool, int и др.). При задании типа
данных С++ его имя необходимо указать в виде строки. Если слот не принимает параметров,
типы не указываются. В параметре name можно передать имя слота в виде строки.
Если этот параметр не задан, в качестве имени слота будет использовано имя метода.
Параметр result задает тип результата, возвращаемого слотом. Если слот не возвращает
результата, этот параметр не задается.
Превращать метод, используемый в качестве обработчика сигнала, в слот необязательно.
Однако вызов слота выполняется быстрее вызова обычного метода.
"""

import sys
from PySide6.QtWidgets import (QApplication,
                               QMainWindow,
                               QPushButton,
                               )
from PySide6.QtCore import QObject, Slot

"""
Импорт модуля sys, предоставляющего доступ к объекта интерпретатора, нужен для доступа
к аргументам командной строки. Если использование аргументов командной строки не предполагается,
то импорт можно не выполнять. При этом, при создании приложения в класс QtWidgets.QApplication([])
в качестве аргумента передается пустой.

Импорт из модуля PySide6.QWidgets класса управления приложением QApplication, класса главных окон QMainWindow,
класса виджета кнопки QPushButton

Импорт из модуля PySide6.QtCore базового класса объектов PySide6 QObject, класса декоратора слота Slot
"""


class CustomHandler(QObject):
    """
    Класс пользовательского обработчика
    """

    def __init__(self):
        """
        Конструктор пользовательского обработчика
        """
        QObject.__init__(self)  # явный вызов конструктора родительского класса

    @staticmethod
    @Slot()
    def on_clicked():
        print('Кнопка нажата. Слот on_clicked()')

    @staticmethod
    @Slot(bool, name='myslot')
    def on_clicked_2(status):
        print('Кнопка нажата. Слот myslot(bool)', status)


class MainWindow(QMainWindow):
    """
    Класс главного окна приложения от супер класса главных окон
    """

    def __init__(self, parent=None) -> None:
        """
        Конструктор главного окна приложения
        """
        QMainWindow.__init__(self, parent)  # явный вызов конструктора родительского класса
        self.setWindowTitle('Пользовательские слоты')  # установка заголовка окна
        self.setFixedSize(300, 300)  # установка фиксированного размера окна
        self.btn = QPushButton('Нажми меня', self)  # создание виджета кнопки с указанием родительского объекта
        self.btn.setFixedSize(150, 30)  # установка фиксированного размера кнопки
        self.btn.move(75, 135)  # смещение кнопки относительно левого верхнего угла окна
        obj = CustomHandler()  # создание экземпляра обработчика сигнала
        self.btn.clicked.connect(obj.on_clicked)  # создание сигнала на нажатие кнопки с привязкой слота
        self.btn.clicked.connect(obj.on_clicked_2)  # создание сигнала на нажатие кнопки с привязкой слота


if __name__ == '__main__':  # проверка условия запуска данного файла для предотвращения запуска кода верхнего уровня
    # при импортировании данного файла как модуля
    app = QApplication(sys.argv)  # создание основного цикла событий приложения
    app.setStyle('Fusion')  # установка более красивого стиля графического интерфейса
    window = MainWindow()  # создание главного окна приложения
    window.show()  # вывод окна на экран, по умолчанию окно спрятано
    sys.exit(app.exec())  # Запуск основного цикла событий приложения.
    # Код ниже метода запуска цикла событий не будет достигнут и выполнен пока не будет выполнен
    # выход и цикл событий не будет остановлен. Не обязательно оборачивать запуск цикла в метод sys.exit()
