"""
Работа с растровыми изображениями. Класс QBitmap.

Класс QBitmap предназначен для работы в контекстно-зависимом представлении с монохромными
изображениями. Наиболее часто класс QBi tmap используется для создания масок изображений.
Иерархия наследования:
QPaintDevice - QPixmap - QBitmap.
Поскольку класс QBi tmap наследует класс QPaintDevice, мы можем использовать его как
поверхность для рисования. Цвет пера и кисти задается элементами color0 (прозрачный
цвет) и color1 (непрозрачный цвет) перечисления GlobalColor из модуля QtCore.Qt. Вывести
изображение позволяет метод drawPixmap() класса QPainter(см 25_2_3_draw_pics.py
и 25_3_1_QPixmap.py).

Форматы конструктора класса:
QBitmap()
QBitmap(<Ширина>, <Высота>)
QBitmap(<Размеры QSize>)
QBitmap(<Путь к файлу>[, format=None])
QBitmap(<Изображение QPixmap>)
QBitmap(<Исходный объект QBitmap>)

Класс QBitmap наследует все методы класса QPixmap и определяет следующие дополнительные
методы (здесь приведены наиболее употребимые - полный их список можно найти
на странице https://doc.qt.io/qt-6/qbltmap.html):
♦ fromImage() - статический, преобразует заданный объект класса QImage в объект класса
QBitmap, который и возвращает. Формат метода:
fromImage(<Изображение QImage>[, flags=ImageConversionFlag.AutoColor])
♦ transformed(<Трансформация QTransform>) - производит трансформацию изображения
(например, поворот) и возвращает объект класса QBitmap. Исходное изображение не изменяется;
♦ clear() - очищает изображение, устанавливая у всех точек изображения цвет color0.
"""

import os

from PySide6.QtWidgets import (QMainWindow,
                               )
from PySide6.QtGui import (QPainter,
                           QPixmap,
                           QImage,
                           Qt,
                           QTransform,
                           QBitmap,
                           QFont,
                           )

"""
Импорт модуля os для работы с переменными интерпретатора 

Импорт из модуля PySide6.QtWidgets класса главных окон QMainWindow

Импорт из модуля PySide6.QtGui класса рисовальщика QPainter,
класса для работы с изображениями в контекстно-зависимом представлении QPixmap,
класса для работы с изображениями в контекстно-независимом представлении QImage,
класса перечислителя настроек виджетов Qt, класса преобразований изображений QTransform,
класса монохромного изображения QBitmap, класса шрифтов QFont
"""


class MainWindow(QMainWindow):
    """
    Класс главного окна приложения от супер класса главных окон
    """

    def __init__(self, parent=None) -> None:
        """
        Конструктор главного окна приложения
        :param parent: ссылка на родительский объект
        """
        QMainWindow.__init__(self, parent)  # явный вызов конструктора родительского класса
        # super().__init__(parent)  # вызов конструктора родительского класса через функцию super()
        self.resize(600, 600)  # установка исходных размеров главного окна приложения
        self.setWindowTitle('Класс QBitmap')  # установка имени главного окна приложения
        self.pix_1 = QPixmap(os.path.join('data', 'photo.jpg'))  # создание объекта изображения из файла
        mask = QBitmap(self.pix_1.size())  # создание маски с размером, полученным из изображения
        mask.clear()  # очистка маски изображения
        painter = QPainter()  # создание объекта рисовальщика
        painter.begin(mask)  # начало записи команд рисовальщика для маски
        painter.setPen(Qt.GlobalColor.color1)  # настройка пера
        painter.setBrush(Qt.GlobalColor.color0)  # настройка кисти
        painter.setFont(QFont('Tahoma', 26, weight=75))  # настройка шрифта
        painter.setRenderHint(QPainter.RenderHint.TextAntialiasing)  # настройка сглаживания шрифта
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)  # настройка сглаживания изображений
        painter.drawText(0, 0, 500, 50, Qt.AlignmentFlag.AlignCenter, 'Камеронова галерея')
        # вывод текста и настройка его выравнивания
        painter.drawEllipse(50, 50, 400, 250)  # рисование эллипса
        painter.end()  # завершение записи команд для маски
        self.pix_1.setMask(mask)  # применение маски к изображению

        img = QImage(os.path.join('data', 'photo.jpg'))  # создание объекта изображения из файла
        self.pix_2 = QBitmap.fromImage(img)  # создание маски из объекта QImage
        m = QTransform()  # создание объекта трансформаций изображение
        m.rotate(90.0)  # добавление поворота в объект трансформаций
        self.pix_2 = self.pix_2.transformed(m)  # применение трансформаций к изображению с его перезаписью в аттрибуте

    def paintEvent(self, event) -> None:
        """
        Обработчик события рисования
        :param event: событие рисования
        :return: None
        """
        painter = QPainter(self)  # создание объекта рисовальщика с подключением поверхности рисования
        painter.drawPixmap(0, 0, self.pix_1)  # вывод изображения в область рисования
        painter.drawPixmap(300, 0, self.pix_2)  # вывод изображения в область рисования


if __name__ == '__main__':  # проверка условия запуска для предотвращения
    # запуска кода верхнего уровня при импортировании данного файла как модуля
    from PySide6.QtWidgets import QApplication
    import sys

    """
    Импорт из модуля PySide6.QtWidgets класса управления приложением QApplication
    Импорт модуля sys, предоставляющего доступ к объекта интерпретатора, нужен для доступа
    к аргументам командной строки. Если использование аргументов командной строки не предполагается,
    то импорт можно не выполнять. При этом, при создании приложения в класс QtWidgets.QApplication([])
    в качестве аргумента передается пустой список.
    """
    app = QApplication(sys.argv)  # создание основного цикла событий приложения
    app.setStyle('Fusion')  # установка более красивого стиля оформления виджетов
    window = MainWindow()  # создание экземпляра главного окна приложения
    window.show()  # включение видимости окна, по умолчанию окно спрятано
    sys.exit(app.exec())  # Запуск основного цикла событий приложения.
    # Код ниже метода запуска цикла событий не будет достигнут и выполнен пока не будет выполнен
    # выход и цикл событий не будет остановлен. Не обязательно оборачивать запуск цикла в метод выхода
